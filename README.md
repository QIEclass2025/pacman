# [개발 보고서] Python과 Pygame을 활용한 아케이드 게임 'Pac-Man' 구현

## 1. 개요 
본 프로젝트의 목적은 고전 아케이드 게임 '팩맨(Pac-Man)'을 파이썬의 `Pygame` 라이브러리를 사용하여 재현하는 것이다. 단순한 캐릭터의 이동뿐만 아니라, 원작의 정교한 유령 알고리즘, 그리고 외부 REST API(PokeAPI)를 활용한 동적 리소스 로딩 기능을 구현하는 것을 목표로 하였다.

## 2. 시스템 설계

### 2.1 클래스 구조
객체 지향 프로그래밍(OOP) 원칙을 적용하여 게임의 유지 보수성과 확장성을 높였다.

* **`GameController`**: 게임의 전체 수명 주기(초기화, 루프, 렌더링, 종료)를 관리하는 메인 클래스.
* **`Level`**: 맵 데이터를 파싱하고 벽, 펠릿(점수 아이템), 유령의 집 위치 정보를 관리.
* **`Vector2`**: 2차원 좌표 계산을 위한 유틸리티 클래스 (벡터 덧셈, 뺄셈, 크기 계산 등 연산자 오버로딩 구현).
* **`Entity`**: 움직이는 모든 객체(팩맨, 유령)의 부모 클래스로, 위치 보정 및 기본 이동 로직을 담당.
    * **`Pacman`**: 사용자 입력을 받아 이동하며 애니메이션과 생명력을 관리.
    * **`Ghost`**: 유령의 공통 상태(추적, 도망, 귀환 등)를 관리.
        * **`Blinky`, `Pinky`, `Inky`, `Clyde`**: 각기 다른 `Target Tile` 계산 로직을 가진 4가지 유령 클래스.

### 2.2 좌표계 시스템
* **타일 좌표**: 맵의 논리적 위치(그리드)를 표현. 길찾기 알고리즘에 사용.
* **픽셀 좌표**: 화면상의 실제 위치. 부드러운 이동 애니메이션을 위해 사용하며, 타일 좌표와의 동기화 로직이 포함됨.

## 3. 핵심 알고리즘 및 구현 상세

### 3.1 유령 알고리즘
각 유령은 플레이어(팩맨)를 단순히 쫓는 것이 아니라, 고유의 성격을 가진다.

1. **Blinky (빨강)**: 팩맨의 현재 타일 좌표를 직접 목표로 삼아 추적한다. 펠릿이 줄어들면 속도가 빨라지는 'Cruise Elroy' 메커니즘이 구현되었다.
2. **Pinky (핑크)**: 팩맨이 바라보는 방향의 앞 4칸을 목표로 하여 매복을 시도한다.
3. **Inky (청록)**: 팩맨의 위치와 Blinky의 위치를 기반으로 벡터 연산을 수행하여 협공 위치를 계산한다.
4. **Clyde (주황)**: 팩맨과 거리가 멀면 쫓아가지만, 가까워지면(8타일 이내) 오히려 자신의 구석진 집으로 도망가는 산개(Scatter) 패턴을 보인다.

### 3.2 상태
유령의 행동 패턴은 상태에 따라 제어된다.

* **Scatter & Chase**: 타이머(Wave System)에 의해 주기적으로 산개 모드와 추적 모드를 오가며 난이도를 조절한다.
* **Frightened (공포)**: 팩맨이 파워 펠릿을 먹으면 유령은 파랗게 변하고 속도가 느려지며, 무작위로 이동한다.
* **Eaten (먹힘)**: 팩맨에게 잡히면 '눈알' 상태가 되어 이동 속도가 급격히 빨라지며 집으로 귀환한다.

### 3.3 길찾기 알고리즘 (BFS)
유령이 팩맨에게 잡혀 `Eaten` 상태가 되었을 때, 유령의 집(Spawn Point)으로 돌아가는 경로는 **너비 우선 탐색(BFS, Breadth-First Search)** 알고리즘을 사용하여 최단 거리로 계산한다.

### 3.4 외부 API 연동 (PokeAPI)
`requests` 라이브러리를 사용하여 게임 시작 시 **PokeAPI**에 접속, 특정 포켓몬(Cherubi, Bounsweet, Applin)의 이미지를 받아와 게임 내 과일(Bonus Item)로 활용한다. 

## 4. 문제 해결 (Troubleshooting)

### 4.1 이동 시 픽셀-타일 불일치 문제
* **문제:** 캐릭터가 부드럽게 이동해야 하지만, 벽 충돌 판정은 격자(Grid) 단위로 이루어져야 해서 코너를 돌 때 좌표가 어긋나는 현상 발생.
* **해결:** `Entity` 클래스에서 픽셀 좌표가 타일의 중심에 도달했을 때만 방향 전환 입력을 처리하고 좌표를 보정(Snapping)하는 로직을 추가하여 해결.

### 4.2 리소스 로딩 예외 처리
* **문제:** 외부 API 통신 실패나 로컬 이미지 파일 누락 시 게임이 강제 종료될 위험.
* **해결:** `try-except` 블록을 활용하여 이미지를 불러오지 못할 경우 기본 도형(원, 사각형)으로 렌더링하도록 대체(Fallback) 로직을 구현하여 프로그램의 안정성을 확보.

### 4.3 게임 오버 시 재시도 편의성 개선
* **문제:** 게임 오버가 되었을 때 바로 프로그램이 종료가 되어 다시 시도할 때 번거로움.
* **해결:** `while` 문의 루프를 활용하여 게임 오버 시 재시도를 할 수 있는 버튼과 프로그램 종료를 할 수 있는 버튼을 추가하여 편의성을 확보

### 4.4 라운드 시스템 추가
* **문제:** 맵 내 모든 펠릿을 획득하면 `You won`이라는 문구와 함께 프로그램이 종료되는데 게임이 너무 빨리 끝나고 최고 점수가 어느정도 정해져있음.
* **해결:** 맵 내 모든 펠릿을 획득하면 다음 라운드로 넘어가며 맵이 초기화되어 펠릿 획득을 통해 계속해서 점수를 높일 수 있으며 고스트들의 속도가 증가해 난이도가 어려워지도록 함.


## 5. 결론 및 향후 개선 사항

### 5.1 결론
본 프로젝트는 Pygame을 활용하여 고전 게임의 복잡한 로직을 성공적으로 구현하였다. 특히 4가지 유령의 개별적인 AI 알고리즘과 상태 변화 시스템을 완벽하게 동작시킴으로써 원작의 긴장감을 재현하는 데 성공했다. 또한, 외부 API를 활용하여 게임 콘텐츠의 확장 가능성을 확인하였다.

### 5.2 향후 과제
* **원본 게임과의 차별점:** 기존의 게임과 시스템과 규칙들이 똑같다는 단점이 있었다. 따라서 추가로 기존의 파워 펠릿의 **Frightened(공포)** 발현 기능 이외에 포켓몬의 타입 <span style="color: #808080">(불꽃, 물, 풀 등)</span> 중 하나가 랜덤으로 지정되도록 하고 그에 맞는 디버프 효과<span style="color: #808080">(방향키 좌우상하 대칭, 목숨 감소, 이동속도 감소 등)</span>를 부여하도록 시스템 변경을 통한 차이점을 보이는 것이 좋아보인다. 또한 새로운 고스트 알고리즘을 추가하는 것도 좋은 선택지로 보인다.
* **동적인 API 활용:** 현재 API가 사용되는 곳은 그저 **PokeAPI**에서 이미지를 가져와 프로그램 내 개체에 적용하는데 사용되어 데이터를 동적으로 활용하는 API의 특징에 걸맞지 않았다. 이에 대한 API를 활용한 동적인 시스템 추가가 필요해 보였다.